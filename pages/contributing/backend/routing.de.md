# Routing-Engine

Wie komme ich von Punkt A nach Punkt B? Das ist die Frage, die unsere Entwickler bei Catenary derzeit zu lösen versuchen. Eine sehr gefragte (und wesentliche) Kartenfunktion ist die Möglichkeit, Routen zwischen Orten zu finden und Fahrten im Voraus zu planen. Wenn Sie zum Beispiel auf einer Reise in einer unbekannten Gegend wären, möchten Sie vielleicht herausfinden, welche Busse/Züge Sie nehmen müssen oder wie Sie zu den Stationen laufen. Diese Art von Funktion existiert in vielen anderen Kartenprogrammen, aber Catenary hat noch keine implementiert. Es ist in Arbeit, und wir können Ihre Hilfe gebrauchen!

Nun, lassen Sie uns zu den interessanten Teilen kommen. Von hier an wird es leider viel technischer, es lässt sich nicht vermeiden. Bereit?


## Graphenalgorithmen
Das Routing-Problem (Finden eines Pfades zwischen den Punkten A und B) wird in der Informatik am häufigsten mit Graphen in Verbindung gebracht. Nein, nicht die Art von y = f(x) Graph, wir sprechen hier von einer anderen Art – der Datenstruktur!

An sich ist es eine ziemlich einfache Idee: Jeder Datenpunkt wird als **Knoten (Node)** dargestellt, und diese Knoten sind mit verwandten Datenpunkten durch eine Einbahnverbindung verbunden, die als **Bogen (Arc)** bezeichnet wird. Die Idee eines Graphen ist eigentlich noch einfacher zu verstehen, wenn man ihn sich als ein buchstäbliches Verkehrsnetz vorstellt – jede Bushaltestelle, jeder Bahnhof, jedes Fährterminal usw. kann als Knoten gesehen werden, während der Weg, den das Fahrzeug zwischen den Haltestellen nimmt, die Bögen sind. Manchmal sehen Sie vielleicht auch das Wort **Kante (Edge)** – Eine Kante ist einfach ein Zwei-Wege-Bogen, bei dem Sie auf derselben Linie hin und her reisen können. Dies ist im Verkehrswesen nicht üblich, da das zurückkehrende Fahrzeug aus der entgegengesetzten Richtung abfährt, aber bei Fußwegen (das heißt, wenn Sie auf einem Bürgersteig gehen) ist dies normalerweise der Fall.

Nun wollen wir insbesondere den **optimalen Pfad** zwischen zwei Orten finden, was bedeutet, dass wir Algorithmen verwenden werden, die sich auf Graphentraversierung und Kürzeste-Pfade-Algorithmen beziehen. Insbesondere gibt es den Dijkstra-Algorithmus, der im Grunde alle möglichen Pfade untersucht, die von einem einzelnen Knoten ausgehen, und den kürzesten zu jedem anderen damit verbundenen Knoten auswählt. Denken Sie daran, dass wir nicht immer nach dem kürzesten Weg nach Entfernung suchen, sondern nach dem Weg, der auf die eine oder andere Weise am wenigsten "kostet", wie z. B. die geringste Wartezeit zwischen Transfers oder der geringste Fußweg zum Erreichen einer Station. In der Zwischenzeit müssen wir auch die Fahrpläne des vorliegenden Verkehrsnetzes berücksichtigen, denn im Gegensatz zu Autos sind Transitfahrzeuge an Haltestellen entlang bestimmter Routen gebunden und passieren diese Haltestellen nur ab und zu, also muss alles sorgfältig getimt werden (einschließlich der Berücksichtigung von Verspätungen!)


## Zeug, das wir lesen (Literaturrecherche)

### Transfer Patterns (TP)
"Transfer Patterns" ist die Abkürzung für *Fast Routing in Very Large Public Transportation Networks using Transfer Patterns*, das [Forschungspapier](https://ad.informatik.uni-freiburg.de/files/transferpatterns.pdf). Dieses Papier lieferte uns viele Ideen, wie wir unseren eigenen Algorithmus schreiben können.

In diesem Papier skizzierten die Autoren, wie man aus Verkehrsdaten die optimalen Umstiege berechnet, die man nehmen muss, um von einem Punkt auf der Karte zu einem anderen zu gelangen. Der Begriff "Transfer Pattern" selbst bezieht sich auf die Menge von Fahrzeugen, die ein Benutzer nehmen könnte, um Haltestelle B von Haltestelle A zu erreichen (z. B. wäre ein potenzielles TP in einem imaginären Verkehrsnetz, die Metro Blue Line von Main-Roosevelt nach 2nd-Roosevelt zu nehmen und dann die Green Line von 1st-Roosevelt zur Central Station zu nehmen).

Die Erstautorin, Dr. Hannah Bast, veröffentlichte später mit ihren Kollegen ein weiteres Papier, in dem auch eine [skalierbare Version](https://ad-publications.cs.uni-freiburg.de/ALENEX_scalable_tp_BHS_2016.pdf) dieses Algorithmus-Sets beschrieben wird. Tatsächlich veröffentlichte Dr. Bast eine [Videokursreihe](https://ad-wiki.informatik.uni-freiburg.de/teaching/EfficientRoutePlanningSS2012), die den Zuschauer durch verschiedene Routing-Algorithmen führt und dazu führt, dass sie die Studenten ein paar Ideen aus dem Papier selbst in Code implementieren lässt.

"Wow, das ist genau das, was wir brauchen!" rufen Sie aus: "Es ist wahrscheinlich alles ein Kinderspiel, jetzt wo ihr einen Anfang gefunden habt, oder?"

Ja und nein. Während dieses Papier und der Kurs erstaunlich und informativ sind, enthalten sie keinen funktionierenden Code – nur Code-Skelette mit bestenfalls Vorschlägen, und es ist auf objektorientiertes C++/Java zugeschnitten, anstatt auf Rust-Syntax. Der Kurs behandelt auch keine vollständige Implementierung des Papiers, sondern nur ein Programm, um zu zählen, wie viele optimale Umstiege es braucht, um von einer zufälligen Station A zu allen Stationen B zu reisen, die damit verbunden sind. Zum einen brauchen wir eine funktionierende Kopie dieses Codes. Was bedeutet: viel Programmieren, Testen, Programmieren, Testen usw. Aber auch wir wollen unseren eigenen Algorithmus implementieren, anstatt vorhandenen Code zu kopieren!

### Wie funktioniert der Catenary-Code?

1) Nehmen Sie einen Satz von GTFS-Fahrplandateien (in ihrer ZIP-Form) und lesen Sie ihn. Verwandeln Sie diese Daten in einen TimeExpandedGraph (TEG). Im Grunde erstellt er, anstatt nur einen Knoten pro Haltestelle zu erstellen, *jedes Mal drei Knoten, wenn ein Fahrzeug eine Haltestelle erreicht*: Einen Knoten, um die Ankunft des Fahrzeugs darzustellen, einen Knoten für seine Abfahrt und einen Knoten, um einen Übergangszustand darzustellen, um mögliche Umstiege zu machen.

Verwenden Sie auch den GTFS-Fahrplan, um eine Tabelle potenzieller Umstiege zwischen Routen zu erstellen, die ein Fahrgast nehmen kann, so dass bei einer gegebenen Zeit und zwei Stationen von zwei verschiedenen Routen die Tabelle die Umsteigestation zwischen diesen Routen zurückgibt. Dies wird als Satz von DirectConnections (DCs) bezeichnet.

Beide Prozesse werden von [transit_networks.rs](https://github.com/catenarytransit/catenary-routing-engine/blob/main/src/transit_network.rs) in unserem Code durchgeführt.

2) Generieren Sie eine TransitDijkstra-Struktur aus dem im vorherigen Abschnitt erstellten TEG. Dies ist im Wesentlichen ein Wrapper für den TEG, enthält aber auch eine Variable, cost_upper_bound, die hilft, Dijkstra-Suchen zu stoppen, wenn die Zeit zum Erreichen von Knoten die genannten Kosten übersteigt. Die Struktur implementiert auch den titelgebenden Dijkstra-Algorithmus und seine Hilfsfunktionen. Der Grund, warum der Autor keine vorhandene Bibliothek für Dijkstra verwendet hat, liegt an den einzigartigen Anforderungen der Datenstruktur sowie dem hohen Overhead für andere Bibliotheken, die Funktionen integrieren, die für dieses Projekt unnötig sind.

Dieser Code ist in [transit_dijkstras.rs](https://github.com/catenarytransit/catenary-routing-engine/blob/main/src/transit_dijkstras.rs) gespeichert.

Diese Datei enthält auch die Struktur PathedNode, die eine Version einer verknüpften Liste ist, die hilft, den Pfad-vom-Ursprung für jeden erreichten Knoten nach Verwendung des Dijkstra-Algorithmus auf einem Graphen zu verfolgen.

Darüber hinaus gibt es auch eine Struktur namens Time Dependent Dijkstra (TDD), die auf den zuvor erwähnten DCs aufbaut, aber darauf kommen wir später zurück!

3) Nun, da wir unsere Daten organisiert haben, ist es Zeit für die Vorverarbeitung. Dies nimmt den Großteil der beteiligten Berechnung ein (hohe Komplexität!) und verwandelt unseren TEG in eine viel komprimiertere Datenstruktur, die die Umstiege verwendet, nach denen das Papier benannt ist, QueryGraph. Die Konvertierung wird von der Funktion query_graph_construction durchgeführt, die sich in [transfers.rs](https://github.com/catenarytransit/catenary-routing-engine/blob/main/src/transfers.rs) befindet. Da dieser Prozess kompliziert ist, lassen Sie uns ihn weiter aufschlüsseln:

    1) Zuerst nimmt query_graph_construction zwei Punkte (geografische Koordinaten) entgegen, um den Start- und Endpunkt einer Reise darzustellen. Unter Verwendung der Start- und Endpunkte ruft es die Funktion stations_near_points auf, um ihre nächstgelegenen Stationen innerhalb einer festgelegten Entfernung zu finden und sie entsprechend als Quell- und Zielstationen zu gruppieren. Dann ruft das Programm hub_selection auf, um die oberen 1% der am besten verbundenen Stationen im Netzwerk auszuwählen. Die Art und Weise, wie hub_selection die Konnektivität bestimmt, besteht darin, eine einfache Version von Dijkstra (durch Ignorieren von Zeitstempeln und Fahrten) durch die TransitDijkstra-Struktur zehntausende Male laufen zu lassen und die Knoten auszuwählen, die am häufigsten besucht werden.

    2) Als nächstes nimmt die Funktion diese Hubs und führt die lokale Version von transfers_from_source von jeder Quellstation aus. Die lokale Funktion transfers_from_source (der ein Option-Some-Wert für das Hubs-Feld übergeben wurde) führt Dijkstra für einen Knoten aus, bis sie einen Hub findet, und stoppt dann und speichert die Pfade, die der Algorithmus genommen hat, als einen Vektor mit jeder der Stationen, an denen ein Fahrgast umsteigen müsste. Durch die Verwendung von Hubs können wir den Overhead für die Berechnung von Pfaden reduzieren, da die lokale Version von transfers_from_source kleinere Suchen durchführt. Um die Hubs mit den Zielen zu verbinden, müssen wir jedoch die globale Version von transfers_from_source (mit Option-None-Wert für Hubs) verwenden, so dass es länger dauern wird.

    3) Jetzt bereinigen wir die Transfervektoren und reihen sie aneinander, um einen neuen, abgeschwächten Graphen zu erstellen, der jede mögliche Kombination von Umstiegen angibt, die ein Fahrgast nehmen kann, um vom Start zum Ende seiner Reise zu gelangen. Dieser einfache Graph wird zusammen mit einigen anderen hilfreichen Informationen (Quellstationen, Zielstationen, Hubs usw.) in QueryGraph gespeichert und als Struktur zurückgegeben. Wir können diese Struktur auch in eine JSON-Datei schreiben, um den Code bis jetzt manuell zu überprüfen – das ist es, was serde-json tut!

4) Schließlich führen wir die Funktion query_graph_search aus, um nach dem besten Weg zu suchen, den der Fahrgast nehmen sollte, um zu seinem Ziel zu gelangen. Unter Verwendung von QueryGraph erstellen wir schnell eine Time Dependent Dijkstra-Struktur, indem wir die Umstiege mit den Direct Connections vergleichen, um zu sehen, welche Umstiege die geringste Zeit in Anspruch nehmen, und führen dann eine letzte Iteration des Dijkstra-Algorithmus von der Quelle zur Zielstation aus, um die besten Abfahrts-/Ankunftszeiten zu finden. Wir melden dem Benutzer den endgültigen Pfad, und das war's!

### [Der Code](https://github.com/catenarytransit/catenary-routing-engine)
Das oben Genannte ist derzeit alles, was wir bisher für das Routing haben. Der Autor arbeitet daran, alle Funktionen zu kommentieren, aber alles ist noch in Arbeit. Fühlen Sie sich frei, die Catenary-Entwickler über Ihren bevorzugten Kontaktweg zu erreichen und alle Fragen zu stellen, die Sie haben!
