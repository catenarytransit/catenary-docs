# Moteur de routage

Comment aller du point A au point B ? C'est la question que nos développeurs chez Catenary essaient actuellement de résoudre. Une fonctionnalité cartographique très demandée (et essentielle) est la capacité de trouver des itinéraires entre des emplacements et de planifier des voyages à l'avance. Par exemple, si vous étiez en voyage dans une zone inconnue, vous voudriez peut-être savoir quels bus/trains prendre ou comment marcher jusqu'aux gares. Ce genre de fonctionnalité existe dans de nombreux autres programmes cartographiques, mais Catenary ne l'a pas encore implémentée. C'est en cours, et nous pouvons utiliser votre aide !

Maintenant, entrons dans les détails croustillants. Cela va devenir beaucoup plus technique à partir d'ici, malheureusement, on ne peut pas l'éviter. Prêt ?

## Algorithmes de graphe
Le problème de routage (trouver un chemin entre les points A et B) est le plus souvent associé aux graphes en informatique. Non, pas le genre de graphique y = f(x), nous parlons d'un autre type ici — la structure de données !

En soi, c'est une idée assez simple : chaque point de données est représenté comme un **nœud**, et ces nœuds sont connectés à des points de données liés par une connexion unidirectionnelle appelée un **arc**. L'idée d'un graphe est en fait encore plus facile à comprendre quand on y pense comme à un réseau de transport littéral — chaque arrêt de bus, gare, terminal de ferry, etc. peut être vu comme un nœud, tandis que le chemin que le véhicule emprunte entre les arrêts sont les arcs. Parfois, vous pouvez voir le mot **arête** (edge) aussi — Une arête est simplement un arc bidirectionnel, où vous pouvez voyager dans les deux sens le long de la même ligne. Ce n'est pas courant dans les transports en commun puisque le véhicule de retour part de la direction opposée, mais avec les sentiers pédestres (c'est-à-dire, si vous marchez sur un trottoir), c'est généralement le cas.

Maintenant, en particulier, nous voulons trouver le **chemin optimal** entre deux emplacements, ce qui signifie que nous utiliserons des algorithmes liés au parcours de graphe et aux algorithmes de chemin le plus court. En particulier, il y a l'algorithme de Dijkstra, qui explore essentiellement tous les chemins possibles sortant d'un seul nœud, et choisit le plus court vers chaque autre nœud connecté à celui-ci. Gardez à l'esprit que nous ne recherchons pas toujours le chemin le plus court en distance, mais le chemin qui "coûte" le moins cher d'une manière ou d'une autre, comme le moins de temps d'attente entre les transferts ou le moins de marche nécessaire pour atteindre une gare. En attendant, nous devons également prendre en compte les horaires du réseau de transport en main car contrairement aux voitures, les véhicules de transport en commun sont conformes aux arrêts le long de certains itinéraires et ils ne passent par ces arrêts que de temps en temps, donc tout doit être chronométré avec soin (y compris pour tenir compte des retards !)

## Choses que nous avons lues (Revue de la littérature)

### Transfer Patterns (TP)
"Transfer Patterns" est l'abréviation de *Fast Routing in Very Large Public Transportation Networks using Transfer Patterns*, l'[article de recherche](https://ad.informatik.uni-freiburg.de/files/transferpatterns.pdf). Cet article nous a fourni beaucoup d'idées pour commencer à écrire notre propre algorithme.

Dans cet article, les auteurs ont souligné comment calculer, à partir de données de transport, le(s) transfert(s) optimal(aux) à prendre pour aller d'un point de la carte à un autre. Le terme "modèle de transfert" (transfer pattern) lui-même fait référence à l'ensemble des véhicules qu'un utilisateur pourrait prendre pour atteindre l'arrêt B depuis l'arrêt A (par exemple, un TP potentiel dans un réseau de transport imaginaire serait de prendre la ligne bleue du métro de Main-Roosevelt à 2nd-Roosevelt, puis de prendre la ligne verte de 1st-Roosevelt à Central Station).

Le premier auteur, Dr Hannah Bast, a publié plus tard un autre article avec ses collègues décrivant une [version évolutive](https://ad-publications.cs.uni-freiburg.de/ALENEX_scalable_tp_BHS_2016.pdf) de cet ensemble d'algorithmes également. En fait, le Dr Bast a publié une [série de cours vidéo](https://ad-wiki.informatik.uni-freiburg.de/teaching/EfficientRoutePlanningSS2012) qui guide le spectateur à travers divers algorithmes de routage et l'amène à faire implémenter par les étudiants quelques idées en code à partir de l'article lui-même.

"Wow, c'est exactement ce dont nous avons besoin !" Vous exclamez-vous, "C'est probablement tout simple maintenant que vous avez trouvé par où commencer, n'est-ce pas ?"

Oui et non. Bien que cet article et ce cours soient étonnants et informatifs, ils n'incluent aucun code fonctionnel — seulement des squelettes de code avec des suggestions tout au plus, et c'est adapté pour le C++/Java orienté objet, plutôt que la syntaxe Rust. Le cours ne passe pas en revue une implémentation complète de l'article non plus, seulement un programme pour compter combien de transferts optimaux il faut pour voyager d'une station aléatoire A à toutes les stations B connectées à celle-ci. D'une part, nous avons besoin d'une copie fonctionnelle de ce code. Ce qui signifie, beaucoup de codage, de tests, de codage, de tests, etc. Mais aussi, nous voulons implémenter notre propre algorithme, plutôt que de copier du code existant !

### Comment fonctionne le code Catenary ?

1) Prenez un ensemble de fichiers d'horaires GTFS (sous sa forme ZIP) et lisez-le. Transformez ces données en un TimeExpandedGraph (TEG). En gros, plutôt que de créer un seul nœud par arrêt, il crée *trois nœuds chaque fois qu'un véhicule atteint un arrêt* : un nœud pour représenter l'arrivée du véhicule, un nœud pour son départ et un nœud pour représenter un état de transition pour effectuer tout transfert potentiel.

En outre, utilisez l'horaire GTFS pour créer un tableau de transferts potentiels entre les itinéraires qu'un passager peut prendre, de sorte qu'étant donné une heure et deux stations de deux itinéraires différents, le tableau renverra la station de transfert entre ces itinéraires. Ceci est appelé un ensemble de Connexions Directes (DirectConnections ou DCs).

Ces deux processus sont effectués par [transit_networks.rs](https://github.com/catenarytransit/catenary-routing-engine/blob/main/src/transit_network.rs) dans notre code.

2) Générez une structure TransitDijkstra à partir du TEG créé par la section précédente. C'est essentiellement une enveloppe pour le TEG, mais elle inclut également une variable, cost_upper_bound, qui aide à arrêter les recherches Dijkstra si le temps pour atteindre les nœuds dépasse ledit coût. La structure implémente également l'algorithme de Dijkstra titulaire et ses fonctions d'aide. La raison pour laquelle l'auteur n'a pas utilisé une bibliothèque existante pour Dijkstra est due aux besoins uniques de la structure de données ainsi qu'à la surcharge élevée pour d'autres bibliothèques qui intègrent des fonctions inutiles pour ce projet.

Ce code est stocké dans [transit_dijkstras.rs](https://github.com/catenarytransit/catenary-routing-engine/blob/main/src/transit_dijkstras.rs).

Ce fichier contient également la structure PathedNode, qui est une sorte de version d'une liste chaînée qui aide à suivre le chemin depuis la source pour chaque nœud atteint après avoir utilisé l'algorithme de Dijkstra sur un graphe.

De plus, il y a aussi une structure appelée Time Dependent Dijkstra (TDD) qui est construite à partir des DCs mentionnés précédemment, mais nous y reviendrons plus tard !

3) Maintenant que nous avons organisé nos données, il est temps de faire le prétraitement. Cela prend la majeure partie du calcul impliqué (haute complexité !) et transforme notre TEG en une structure de données beaucoup plus condensée qui utilise les transferts dont l'article tire son nom, QueryGraph. La conversion est exécutée par la fonction query_graph_construction située dans [transfers.rs](https://github.com/catenarytransit/catenary-routing-engine/blob/main/src/transfers.rs). Comme ce processus est compliqué, décomposons-le davantage :

    1) Premièrement, query_graph_construction prend deux Points (coordonnées géographiques), pour représenter les points de départ et d'arrivée d'un voyage. En utilisant les points de début et de fin, il appelle la fonction stations_near_points pour trouver leurs stations les plus proches dans une distance définie, en les regroupant respectivement comme stations source et cible. Ensuite, le programme appellera hub_selection pour sélectionner le top 1% des stations les plus connectées du réseau. La façon dont hub_selection détermine la connectivité est en exécutant une version simple de Dijkstra (en ignorant les horodatages et les voyages) à travers la structure TransitDijkstra, des dizaines de milliers de fois, et en sélectionnant les nœuds les plus visités.

    2) Ensuite, la fonction prend ces hubs et exécute la version locale de transfers_from_source à partir de chaque station source. La fonction locale transfers_from_source (qui a une valeur Option-Some passée pour le champ hubs) exécute Dijkstra pour un nœud jusqu'à ce qu'elle trouve un hub, puis s'arrête, et stocke les chemins que l'algorithme a pris sous forme de vecteur avec chacune des stations où un passager devrait effectuer un transfert. En utilisant des hubs, nous pouvons réduire la surcharge pour calculer les chemins puisque la version locale de transfers_from_source exécute des recherches plus petites. Pour connecter les hubs aux cibles, cependant, nous devrons utiliser la version globale de transfers_from_source (avec la valeur Option-None pour les hubs), donc cela prendra plus de temps.

    3) Maintenant, nous nettoyons les vecteurs de transfert et les enchaînons pour créer un nouveau graphe épuré qui donne toutes les combinaisons possibles de transferts qu'un passager peut prendre pour aller du début à la fin de son voyage. Ce graphe simple, ainsi que d'autres informations utiles (stations source, stations cibles, hubs, etc.) est stocké dans QueryGraph et renvoyé sous forme de structure. Nous pouvons également écrire cette structure dans un fichier JSON pour vérifier manuellement le code jusqu'à présent — c'est ce que fait serde-json !

4) Enfin, nous exécutons la fonction query_graph_search pour rechercher le meilleur chemin que le passager devrait prendre pour arriver à sa destination. En utilisant QueryGraph, nous créons rapidement une structure Time Dependent Dijkstra en comparant les transferts avec les Connexions Directes pour voir quels transferts prennent le moins de temps, puis exécutons une dernière itération de l'algorithme de Dijkstra de la station source à la station cible pour trouver les meilleurs horaires de départ/arrivée. Nous rapportons le chemin final à l'utilisateur, et c'est tout !

### [Le Code](https://github.com/catenarytransit/catenary-routing-engine)
Ce qui précède est actuellement tout ce que nous avons pour le routage, jusqu'à présent. L'auteur travaille à commenter toutes les fonctions, mais tout est un travail en cours. N'hésitez pas à contacter les développeurs Catenary via votre mode de contact préféré et posez toutes les questions que vous avez !
